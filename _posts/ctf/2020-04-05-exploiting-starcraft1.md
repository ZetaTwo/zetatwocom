---
layout: post
title: "Exploiting the Starcraft 1 EUD bug"
date: 2020-04-05 22:00
type: post
published: false
comments: true
categories: ctf
---


* background: the game, the patches, 1.16.1, mention the eud emulator
* the bug: concept, code diff
* the setup: custom map, script, scmdraft
* the ctf challenge: setup
* the exploit
* other exploits
* the eud emulator + links to talk

[Starcraft](TODO), released in 1998, is still one of the best strategy games ever made. Over 20 years later it still has a strong community and [a remastered version](TODO) was released in 2017 with updated graphics and sound. However, like all software, it have had it fair share of bugs. One of these bugs was an arbitrary read/write vulnerability in the parser for the scripts embedded in the maps of the game. As long as I've known about the bug I had assumed it could be used for exploitation but I had never seen a public example of this. Last weekend, I sat down and wrote an exploit myself and also turned this into a challenge for the [Midnight Sun CTF 2020 qualifiers](https://TODO). In this blog post I will go through some background, explain my exploit, how I created a CTF challenge of it and look at some of the ways it was solved.

## The Bug - Extended Unit Death

Eight years after its release, on the 18th of January 2006, Starcraft patch version 1.13f was released. The [patch notes](https://liquipedia.net/starcraft/Patches_1.09-1.15#Patch_1.13f) simply stated "Fixed several bugs that contributed to game exploits". Among other things, it fixed a specific bug that had been dubbed "Extended Unit Death", EUD. The EUD bug got its name from the mechanism it used to allow arbitrary read and write in the program's memory.

Starcraft has a simple scripting system inside the game that allow maps to contain small pieces of code to manipulate some aspects of the game to create things like new game modes or story driven campaign maps. These scripts are called "triggers" and are structured in a simple if-then fashion. Each trigger has a set of "condition" and "actions". When all the conditions of a trigger are met, all the actions will be executed. A trigger can affect specific players or all players of the game. A condition can for example be "move unit X to location Y" and a trigger can be "display text message X" or "create unit Y".

The game also keeps track of how many of each type of unit each player has killed. These are called "death counters" and are simply stored in a table of `<Number of players> x <Number of unit types>` entries. When a unit is killed something equivalent to `unit_deaths[player_id][unit_type]++` is run. These values can then be used in the condition part of a trigger by comparing it against a specific value to determine if the condition is met, essentially making a condition like `if(unit_deaths[current_player][unit_type] == X)`. It can also be manipulated in a trigger action by setting an entry to a specific value, adding or subtracting to it, essentially creating an action like `unit_deaths[player_id][unit_type] =/+=/-= X`. The bug was that in these actions, the unit_type index was not checked against the valid range thus allowing us to read, write, add and subtract values to any offset relative to this array. Furthermore, since the progrem does not have PIE enabled and the array is stored as a global variable it has a known address, we can carefully control the address accessed.



## The Exploit


## The CTF Challenge


## The Solutions


## Conclusion

